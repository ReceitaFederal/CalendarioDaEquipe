<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8">
  <title>Calendário da Equipe</title>

  <link href="https://unpkg.com/vis-timeline@latest/styles/vis-timeline-graph2d.min.css" rel="stylesheet" />
  <script src="https://unpkg.com/vis-timeline@latest/standalone/umd/vis-timeline-graph2d.min.js" defer></script>

  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
    }

    #timeline {
      border: 1px solid #ddd;
      height: 600px;
      margin-top: 10px;
    }

    .controls button,
    .controls input,
    .controls label {
      margin: 5px;
      vertical-align: middle;
    }

    /* Legenda */
    #legend {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
    }

    .legend-item {
      display: inline-flex;
      align-items: center;
      margin-right: 15px;
      font-size: 14px;
    }

    .legend-color-box {
      width: 14px;
      height: 14px;
      margin-right: 6px;
      border: 1px solid #ccc;
    }

    /* Highlight “super legal” */
    .vis-item.highlighted {

      border: 3px solid #000000 !important;

      box-shadow: 0 0 12px 4px rgba(0, 0, 0, 0.8);

    }
  </style>
</head>

<body>
  <h1>Calendário da Equipe</h1>

  <div class="controls">
    <button id="btnReset">Limpar Calendário</button>
    <button id="btnLoadConfig">Carregar Configuração</button>
    <button id="btnLoadCSV">Carregar CSV</button>
    <button id="btnSaveAll">Salvar Calendário Completo</button>
    <button id="btnLoadAll">Carregar Calendário Completo</button>
    <button id="btnCalcDisp">Calcular Disponibilidade</button>
    <input type="file" id="fileInput" style="display:none" />
  </div>
  <!-- CONTROLES PARA INCLUIR PERÍODO MANUAL -->
  <div id="novoPeriodo" class="controls" style="margin-top:10px;">
    <label for="selMembro">Membro:</label>
    <select id="selMembro"></select>

    <label for="selTipo">Tipo:</label>
    <select id="selTipo"></select>

    <label for="dtInicioManual">Início:</label>
    <input type="date" id="dtInicioManual" />

    <label for="dtFimManual">Fim:</label>
    <input type="date" id="dtFimManual" />

    <button id="btnIncluir">Incluir</button>
  </div>
  <div id="legend"></div>
  <div id="timeline"></div>

  <script>
    let config = null;
    let registros = [];
    // Map para guardar id ↔ nome dos membros
    let membrosMap = new Map();

    let container, timeline;
    let items;

    document.addEventListener("DOMContentLoaded", () => {
      container = document.getElementById("timeline");
      inicializarEstruturas();
      inicializarTimeline();
      configurarEventos();
    });

    function inicializarEstruturas() {
      items = new vis.DataSet();
    }

    function inicializarTimeline() {
      const options = {
        stack: true,
        orientation: 'top',
        margin: { item: 10, axis: 5 }
      };
      timeline = new vis.Timeline(container, items, options);

      // Toggle de destaque: clica para adicionar/remover em cada grupo de itens
      timeline.on('click', function (properties) {
        // somente age se clicou num item
        if (!properties.item) return;

        const baseId = properties.item.toString().split('-')[0];

        // percorre cada item cujo id começa com baseId-
        items.get()
          .filter(it => it.id.toString().startsWith(baseId + '-'))
          .forEach(it => {
            const cls = it.className || '';
            const isHighlighted = cls.includes('highlighted');
            // monta nova classe
            const newClass = isHighlighted
              ? cls.replace(/\s*highlighted/g, '')     // remove highlight
              : (cls + ' highlighted');                // adiciona highlight
            items.update({ id: it.id, className: newClass });
          });
      });
    }

    function configurarEventos() {
      document.getElementById("btnReset").onclick = resetarTimeline;
      document.getElementById("btnLoadConfig").onclick = () => selecionarArquivo("json", carregarConfigArquivo);
      document.getElementById("btnLoadCSV").onclick = () => selecionarArquivo("csv", carregarCSVArquivo);
      document.getElementById("btnSaveAll").onclick = salvarCalendarioCompleto;
      document.getElementById("btnLoadAll").onclick = () => selecionarArquivo("json", carregarCalendarioCompleto);
      document.getElementById("btnCalcDisp").onclick = gerarDisponibilidade;
      document.getElementById("btnIncluir").onclick = incluirPeriodoManual;
    }

    function resetarTimeline() {
      inicializarEstruturas();
      timeline.setItems(items);
      config = null;
      registros = [];
      document.getElementById('legend').innerHTML = '';
    }

    function selecionarArquivo(tipo, callback) {
      const input = document.getElementById("fileInput");
      input.accept = tipo === "json" ? ".json" : ".csv";
      input.onchange = e => {
        if (e.target.files[0]) {
          callback(e.target.files[0]);
        }
      };
      input.click();
    }

    function carregarConfigArquivo(file) {
      lerArquivo(file).then(text => {
        config = JSON.parse(text);
        console.log("Configuração carregada", config);
        gerarEstilosDinamicos();
        popularSelectTipo();
        gerarLegenda();
      });
    }

    function gerarEstilosDinamicos() {
      let old = document.getElementById("dynamic-timeline-styles");
      if (old) old.remove();
      const styleEl = document.createElement("style");
      styleEl.id = "dynamic-timeline-styles";
      config.arquivos.forEach(a => {
        styleEl.appendChild(document.createTextNode(
          `.vis-item.${a.identificador_arquivo} { background-color: ${a.cor}; }\n`
        ));
      });
      document.head.appendChild(styleEl);
    }

    function gerarLegenda() {
      const legend = document.getElementById('legend');
      legend.innerHTML = '';
      config.arquivos.forEach(a => {
        if (a.tipo !== 'membros') {
          const item = document.createElement('div');
          item.className = 'legend-item';
          const box = document.createElement('div');
          box.className = 'legend-color-box';
          box.style.backgroundColor = a.cor;
          item.appendChild(box);
          item.appendChild(document.createTextNode(a.nome));
          legend.appendChild(item);
        }
      });
    }

    function carregarCSVArquivo(file) {
      if (!config) { alert("Carregue primeiro uma configuração JSON."); return; }
      lerArquivo(file).then(text => {
        const sep = identificarSeparador(text);
        const dados = parseCSV(text, sep);

        const match = config.arquivos.find(a => file.name.toLowerCase().includes(a.identificador_arquivo.toLowerCase() || ""));
        if (!match) { alert("CSV não corresponde a nenhuma entrada na configuração."); return; }

        if (match.tipo === 'membros') {
          dados.forEach(r =>
            membrosMap.set(r[match.campos.id], r[match.campos.nome])
          );
          popularSelectMembro();
          console.log("Membros carregados:", membrosMap);
          return;
        }

        dados.forEach(r => {
          r.__campos = match.campos;
          r.categoria = match.identificador_arquivo;
          r.nome_categoria = match.nome;
        });
        registros.push(...dados);
        atualizarTimeline();
      });
    }

    function parseDateBR(str) {
      const [dia, mes, ano] = str.split('/');
      return new Date(+ano, mes - 1, +dia);
    }

    function uid() {
  // Usa crypto.randomUUID quando disponível (moderno)
  if (window.crypto?.randomUUID) return crypto.randomUUID();
  // Fallback: timestamp + random (bom o suficiente p/ UI)
  return (Date.now().toString(36) + Math.random().toString(36).slice(2, 10)).toUpperCase();
}

    function atualizarTimeline() {
      items.clear();
      if (registros.length === 0) return;
      registros.forEach(r => {
        const c = r.__campos;
        const inicioBR = r[c.inicio];
        const fimBR = r[c.fim];
        const baseId = r[c.id]; 
        const uniqueId = `${baseId}-${uid()}`;

        if (!inicioBR || !fimBR) return;
        items.add({
          id: uniqueId,
          content: `<strong>${r[c.nome]}</strong>`,
          start: parseDateBR(inicioBR),
          end: parseDateBR(fimBR),
          className: r.categoria,
          title: r.nome_categoria
        });
      });
      timeline.setItems(items);
    }

    function salvarCalendarioCompleto() {
      if (!config) { alert("Nenhuma configuração carregada."); return; }
      const dados = { config, registros };
      const blob = new Blob([JSON.stringify(dados)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url; a.download = "calendario_completo.json"; a.click();
      URL.revokeObjectURL(url);
    }

    function carregarCalendarioCompleto(file) {
      lerArquivo(file).then(text => {
        const obj = JSON.parse(text);
        config = obj.config;
        registros = obj.registros;
        atualizarTimeline();
      });
    }

    function lerArquivo(file) {
      return new Promise((res, rej) => {
        const r = new FileReader();
        r.onload = e => res(e.target.result);
        r.onerror = e => rej(e);
        r.readAsText(file);
      });
    }

    function identificarSeparador(text) {
      return text.includes(";") ? ";" : ",";
    }

    function parseCSV(texto, sep = ",") {
      const linhas = texto.trim().split("\n");
      const cab = linhas.shift().split(sep).map(h => h.trim());
      return linhas.map(l => {
        const cols = l.split(sep).map(c => c.trim());
        return Object.fromEntries(cab.map((h, i) => [h, cols[i]]));
      });
    }

    // --- NOVAS FUNÇÕES DE DISPONIBILIDADE ---
    function gerarDisponibilidade() {
      const size = membrosMap.size;
      const daily = calcularDisponibilidade(size);
      const periods = agruparPeriodos(daily);
      adicionarItensDisponibilidade(periods, size);
    }

    function calcularDisponibilidade(size) {
      const daily = [];
      if (registros.length === 0) return daily;
      // determina intervalo
      let minDate = Infinity, maxDate = -Infinity;
      registros.forEach(r => {
        const start = parseDateBR(r.__campos.inicio ? r[r.__campos.inicio] : r.inicio);
        const end = parseDateBR(r.__campos.fim ? r[r.__campos.fim] : r.fim);
        minDate = Math.min(minDate, start);
        maxDate = Math.max(maxDate, end);
      });
      let curr = new Date(minDate);
      curr.setHours(0, 0, 0, 0);
      const last = new Date(maxDate);
      last.setHours(0, 0, 0, 0);
      while (curr <= last) {
        const date = new Date(curr);
        const busy = registros.filter(r => {
          const start = parseDateBR(r.__campos.inicio ? r[r.__campos.inicio] : r.inicio);
          const end = parseDateBR(r.__campos.fim ? r[r.__campos.fim] : r.fim);
          return date >= start && date <= end;
        }).length;
        daily.push({ date: new Date(date), avail: size - busy });
        curr.setDate(curr.getDate() + 1);
      }
      return daily;
    }

    function agruparPeriodos(daily) {
      const periods = [];
      if (daily.length === 0) return periods;
      let start = daily[0].date;
      let current = daily[0].avail;
      for (let i = 1; i < daily.length; i++) {
        if (daily[i].avail !== current) {
          periods.push({ start, end: daily[i - 1].date, avail: current });
          start = daily[i].date;
          current = daily[i].avail;
        }
      }
      periods.push({ start, end: daily[daily.length - 1].date, avail: current });
      return periods;
    }

    function adicionarItensDisponibilidade(periods, size) {
      // remove antigos background
      items.get({ filter: item => item.type === 'background' }).forEach(it => items.remove(it.id));
      periods.forEach((p, i) => {
        const ratio = size > 0 ? p.avail / size : 0;
        const g = Math.round(ratio * 255);
        const color = `rgb(0,${g},0)`;
        items.add({
          id: `disp-${i}`,
          type: 'background',
          start: p.start,
          end: new Date(p.end.getTime() + 24 * 60 * 60 * 1000), // final do dia
          style: `background-color: ${color};`
        });
      });
      timeline.setItems(items);
    }
    // 3.1) Popular select de membros (após CSV de membros)
    function popularSelectMembro() {
      const sel = document.getElementById("selMembro");
      sel.innerHTML = '<option value="">Selecione</option>';
      membrosMap.forEach((nome, id) => {
        const o = document.createElement("option");
        o.value = id;
        o.textContent = nome;
        sel.appendChild(o);
      });
    }

    // 3.2) Popular select de tipos (após carregar config JSON)
    function popularSelectTipo() {
      const sel = document.getElementById("selTipo");
      sel.innerHTML = '<option value="">Selecione</option>';
      config.arquivos.forEach(a => {
        if (a.tipo !== 'membros') {
          const o = document.createElement("option");
          o.value = a.identificador_arquivo;
          o.textContent = a.nome;
          sel.appendChild(o);
        }
      });
    }

    // 3.3) Formata “yyyy-mm-dd” para “dd/mm/yyyy”
    function formatarDataParaBR(iso) {
      const [y, m, d] = iso.split("-");
      return `${d}/${m}/${y}`;
    }

    // 3.4) Inclui o período manual na timeline
    function incluirPeriodoManual() {
      const idMembro = document.getElementById("selMembro").value;
      const tipo = document.getElementById("selTipo").value;
      const inicio = document.getElementById("dtInicioManual").value;
      const fim = document.getElementById("dtFimManual").value;

      if (!idMembro || !tipo || !inicio || !fim) {
        alert("Preencha todos os campos para incluir o período.");
        return;
      }

      const cfg = config.arquivos.find(a => a.identificador_arquivo === tipo);
      const reg = {};
      reg[cfg.campos.id] = idMembro;
      reg[cfg.campos.nome] = membrosMap.get(idMembro);
      reg[cfg.campos.inicio] = formatarDataParaBR(inicio);
      reg[cfg.campos.fim] = formatarDataParaBR(fim);
      reg.__campos = cfg.campos;
      reg.categoria = cfg.identificador_arquivo;
      reg.nome_categoria = cfg.nome;

      registros.push(reg);
      atualizarTimeline();
    }
  </script>
</body>

</html>